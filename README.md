# Пошаговое описание того, что происходит в JVM при работе программы


### 1-ый этап(ClassLoaders):
* Обращаемся к подсиситеме загрузчиков классов Class Loading, чтобы она подгрузила наши классы(JvmComprehension, Object, Integer, String).
![](https://github.com/DaniilVenikov/core_10.1_JVM-pictures-/blob/origin/1-ый%20скрин.png)
Подсистема состоит из трёх загрузчиков: Application ClassLoader, Platform ClassLoader, Bootstrap ClassLoader (от врехнего уровня до нижнего, в порядке в котором указаны). Application ClassLoader передаёт запрос по цепочке Platform ClassLoader, спрашивая у него "Есть ли такие классы?". Platform ClassLoader в свою очередь также делегирует запрос к Bootstrap ClassLoader, спрашивая у него "Может ли он загрузить эти классы?". Bootstrap ClassLoader пробует загрузить эти классы, если получается, то работа подсистемы заканчивается, классы загружены. Если у него это не получается, то он по обратной цепочке передаёт об этом информацию Platform ClassLoader. Теперь Platform ClassLoader ищет наши классы, если находит, то подгружает, если не находит, то он передаёт об этом информацию Application ClassLoader. Application ClassLoader начинает искать наши классы сам. Если такие классы есть, то он его подгружает, если нет, то будет ошибка ClassNotFoundException. Классы подгружены.
* Далее происходит *связывание(Linking)*. На данном этапе происходит проверка кода на валидность, подгрузка в память примитивов (в нашем коде это только i),статических полей, которых в нашей программе нет и связывание ссылок на другие классы, которых у нас тоже нет.
* Далее идёт стадия *инициализации(Initialization)*. На данном этапе выполняются static инициализаторы и инициализаторы static полей

Загрузка классов завершается. Теперь программа может начать своё выполнение (JVM теперь знает классы, которые могут использоваться)

### 2-ой этап(Runtime Data Area)
* Подсистема загрузки классов загрузила наши класс(JvmComprehension) и системные классы(Object, Integer, String и т.к.) в область памяти Metaspace(В MetaSpace хранятся данные о классах)
* Далее происходит вызов метода main, в момент его вызова создаётся фрейм в стеке(области памяти под названием Stack Memory).
* //1: так как переменная i является примитивом, то при создании она будет записана в стек во фрейм main и ей будет присвоено значение 1.
* //2: сначала будет выполнено выделение памяти под объект(new Object) в куче(heap), затем в стеке создаётся переменная o, которой присваивается ссылка на объект из кучи
* //3: выделенеи памяти в стеке для переменной ii и присвоение ей значения 2
* //4: в стеке создаётся ещё один фрейм printAll, параметру o, метода printAll будет присвоена ссылка на ранее созданный объект o из кучи, оставшимся 2-м параметрам i и ii будут созданы значения 1 и 2, соответсвенно, в стеке во фрейме printAll 
* //5: в стеке, во фрейме printAll создаётся переменная uselessVar и ей присвается значение 700
* //6: создаётся ещё один фрейм под метод println, внутри него будет вызван метод toString, под который в свою очередь тоже будет создан новый фрейм. Метод toStrin отработает, указатель стека передвинется на фрейм println, что будет означать, что данные фрейма toString будут удалены. Метод printl выполнит свою работу указатель стека опять передвинится.
* //7: создатся фрейм в стеке под метод println, он выведет значение на экран, затем фрейм удалится из стека, за ним закончит своё выполнение и метод main

Так как у нас небольшая программа, нет циклических ссылок и все созданные объекты используются, то во время вызова сборщика мусора ничего не будет удалено из кучи
