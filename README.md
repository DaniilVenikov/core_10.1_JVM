# Пошаговое описание того, что происходит в JVM при работе программы


### 1-ый этап(ClassLoaders):
* Обращаемся к подсиситеме загрузчиков классов Class Loading, чтобы она подгрузила наши классы(JvmComprehension, Object, Integer).
Подсистема состоит из трёх загрузчиков: Application ClassLoader, Platform ClassLoader, Bootstrap ClassLoader (от врехнего уровня до нижнего, в порядке в котором указаны). Application ClassLoader передаёт запрос по цепочке Platform ClassLoader, спрашивая у него "Есть ли такие классы?". Platform ClassLoader в свою очередь также делегирует запрос к Bootstrap ClassLoader, спрашивая у него "Может ли он загрузить эти классы?". Bootstrap ClassLoader пробует загрузить эти классы, если получается, то работа подсистемы заканчивается, классы загружены. Если у него это не получается, то он по обратной цепочке передаёт об этом информацию Platform ClassLoader. Теперь Platform ClassLoader ищет наши классы, если находит, то подгружает, если не находит, то он передаёт об этом информацию Application ClassLoader. Application ClassLoader начинает искать наши классы сам. Если такие классы есть, то он его подгружает, если нет, то будет ошибка ClassNotFoundException. Классы подгружены.
* Далее происходит *связывание(Linking)*. На данном этапе происходит проверка кода на валидность, подгрузка в память примитивов (в нашем коде это только i),статических полей, которых в нашей программе нет и связывание ссылок на другие классы, которых у нас тоже нет.
* Далее идёт стадия *инициализации(Initialization)*. На данном этапе выполняются static инициализаторы и инициализаторы static полей

Загрузка классов завершается. Теперь программа может начать своё выполнение (JVM теперь знает классы, которые могут использоваться)

### 2-ой этап(Runtime Data Area)
* Подсистема загрузки классов загрузила наши класс(JvmComprehension) и системные классы(Object, Integer, String и т.к.) в область памяти Metaspace(В MetaSpace хранятся данные о классах)
* Далее происходит вызов метода main, в момент его вызова создаётся фрейм в стеке(области памяти под названием Stack Memory).
//1: так как переменная i является примитивом, то при создании она будет записана в стек во фрейм main и ей будет присвоено значение 1.
//2: сначала будет выполнено выделение памяти под объект(new Object) в куче(heap), затем в стеке создаётся переменная o, которой присваивается ссылка на объект из кучи
//3: выделенеи памяти в стеке для переменной ii и присвоение ей значения 2
//4: в стеке создаётся ещё один фрейм printAll
//5:
